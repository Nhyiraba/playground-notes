\documentclass[11pt,a4paper]{article}
\usepackage{polski}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage[cp1250]{inputenc}
\title{RESTful Web Services Cookbook (Allamaraju)}
\author{Wojciech Gawronski (afronski@gmail.com)}

\begin{document}

\maketitle
\newpage

\tableofcontents
\newpage

\section{Introduction}

\textbf{REST} - Representational State Transfer, architectural style for networked applications.
The REST architectural style was developed in parallel with HTTP/1.1, based on the existing design of HTTP/1.0. The largest implementation of a system conforming to the REST architectural style is the World Wide Web. REST exemplifies how the Web's architecture emerged by characterizing and constraining the macro-interactions of the four components of the Web, namely origin servers, gateways, proxies and clients, without imposing limitations on the individual participants. As such, REST essentially governs the proper behavior of participants.

Key goals of REST include:
\begin{itemize}
	\item Scalability of component interactions.
	\item Generality of interfaces.
	\item Independent deployment of components.
	\item Intermediary components to reduce latency, enforce security and encapsulate legacy systems.
\end{itemize}

REST has been applied to describe the desired web architecture, to help identify existing problems, to compare alternative solutions, and to ensure that protocol extensions would not violate the core constraints that make the Web successful.

\section{Overview}

\begin{itemize}
	\item \textit{Uniform Resource Identifier} - resource name (generic term, a more specific is \textit{Uniform Resource Locator}, in many cases a generic is a valid definition). It is a place from user starts interaction with web application, in most cases URIs are opaque for client. 
	\item \textit{Resources} - anything that can be identified by a URI. URIs are typed by user, and can be an resource address coresponded to the web page. In static website every page is a resource. Also forms \textit{actions} respresented as URIs are addresses to this resource which we're update.
	\item \textit{Representations} - The HTML document returned from server to the clien is a \textit{representation} of resource. Representation is an encapsulation of the information (state, data or markup) encoded in specified format (XML, HTML, JSON etc.). Reosurce can have many representations. Client and servers use \textit{media types} to denote the type of representation to the receiving party (the client or the server). Most websites and applications use HTML format for \textit{text/html} as media type. Similarly, when user submits the form, the browser submits a representantion using URI-encoded format using the \textit{application/x-www-form-urlencoded} media type.
	\item \textit{Uniform Interface} - Clients use \textit{Hypertext Transfer Protocol} to submit requests to resources and get responses. In first case, the client submits \textit{GET} request to fetch an HTML document. In second case user submits \textit{POST} to update user status. These methods are part of HTTP's \textit{uniform interface}. Use of this interface makes request and responses self-describing and visible. In addition to these two methods, this interface consists of other methods such as \textit{OPTIONS}, \textit{HEAD}, \textit{PUT}, \textit{DELETE}, \textit{TRACE} and \textit{CONNECT}. Semantics is well defined for all methods (except for CONNECT from HTTP 1.1 reserved for tunneling TCP-based protocols such as TLS). HTTP is protocol connecting clients and resources. In this protocol, except when you define new methods for extend HTTP, the list and semantics is fixed and independent of the resources. That is why HTTP is called an uniform interface (unline RPC or SOAP-based web services where semantics are application specific).
	\item \textit{Hypermedia and Application State} - Each representation which is sent to the client represents state of the user's interaction within the application. For instance, when user submits the form to receive another page, the user changes the state of the application from her point of view. When a use only browse and view data, it also changes application state by clicking a link and load another page. Change is based on froms and links found inside application and HTML. This is a hypermedia format which allows state changing by specified elements. This way of hypermedia usage is named \textit{hypertext constraint} and \textit{hypermedia as the engine of application state}.
\end{itemize}

\section{HTTP methods}
Referenced from \textit{RFC 2616}, specified definitions are only a shorthand from this specification:

\subsection{OPTIONS}
List of HTTP methods supported by any resource or use in order to ping the server.

\textbf{Request}: Headers, but no body.

\textbf{Response}: Headers, but no body by default. The server may provide a description of resource inside body.

\subsection{GET}
Use this method for retrieve a representation of a resource.

\textbf{Request}: Headers, but no body specified by HTTP 1.1.

\textbf{Response}: A representation of the resource at the request URI usually with a body. Response headers such as \textit{Content-Type}, \textit{Content-Length}, \textit{Last-Modified}, \textit{ETag} and \textit{Content-Language} corresponds to the response representation.

\subsection{HEAD}
Use this method for retrieve same headers as that of a GET response without any data. For checking metadata, headers and resource existance.

\textbf{Request}: Headers, but no body specified by HTTP 1.1.

\textbf{Response}: Headers but no body. Server must not include body.

\subsection{POST}
Use this method to let resource perform variety of actions on the server side such as creating new, updating or making mixture of changes to one or more resources.

\textbf{Request}: Resource representation.

\textbf{Response}: A representation of the resource or instructions for a redirect. If there is a representation inside body that corresponds to the URI of the resource other than request URI include \textit{Content-Location} header with the URI of that resource.

\subsection{PUT}
Use this method to complete object update or replace an existing resource, or either creating a new with URI specified by the client. 

\textbf{Request}: A resource representation. Body may or not may be same as a client would receive for a subsequent GET request, in some cases, the server may require clients to includ only the mutable portions of resource.

\textbf{Response}: Response can be a status of the update. You can include complete representation of updated element, but client cannot assume that response contains a complete representation unless the response includes a \textit{Content-Location} header. If server does not include this header, clients must submit an uncoditional GET request to get the updated representation along with \textit{Last-Modified} and \textit{ETag} headers.

\subsection{DELETE}
Use this method for let the client remove a resource.

\textbf{Request}: Headers, but no body. If you must submit data to delete a resource use POST with a controller resource.

\textbf{Response}: Success of failure. Body may include status of the operation.

\subsection{TRACE}
Use this method for echo back the headers that it received. Servers supporting this method may be prone to cross-site tracking (XST) security vulnerability.

\textbf{Request}: Headers, but no body.

\textbf{Response}: Body contains entire request message.

\section{Receipes}

\subsection{Keep Interactions Visible}
\subsection{Be sure that you can trade off visibility for network efficency or resource granulity}
\subsection{Maintain application state by URIs and resources}
\subsection{Server methods should be safe and idempotent (GET, HEAD etc. should return the same response under concurrent conditions)}
\subsection{Only POST can be unsafe and not idempotent, PUT and DELETE also can be unasfe}

\subsection{GET usage}
\begin{itemize}
	\item Use GET for safe and idempotent information retrival.
	\item Caching and sharding can be used here.
\end{itemize}

\subsection{POST usage}
\begin{itemize}
	\item Create a new resource, using resource as a factory.
	\item To modify one or more resources via controller resource.
	\item To run queries with large inputs.
	\item To perform any unsafe and idempotent operation when other HTTP methods are inapropriate.
\end{itemize}

\subsection{Factory method pattern - creating resources with POST}
Using POST parameter as a prototype for new resource, method can use \textit{slug} for resource identification and \textit{Location} headers (and response code 201) for identyfing new resource.

\subsection{Creating new resource with PUT}
Use PUT to create new resources only when client can decide about URIs of resources. Otherwise use POST (PUT describes action and location where should we put new resource).

\subsection{Asynchronous Tasks - POST}
Use POST method for executing tasks which takes too long to complete. After receiving POST, server responds with 202 (\textit{Accepted}) and returns new location for progress and asynchronous task status tracking. Client can use GET on new resource for progress response information.

\subsection{Asynchronous Deletion - DELETE}
When deletion takes too long, we can technique as above to return new location for progress tracking (and with GET method usage).

\subsection{Custom HTTP methods}
Avoid using custom and nonstandard methods (like WebDAV). Use instead HTTP POST method, because you rely on standard not on the off-the-shelf protocol abilities.

\subsection{Custom HTTP headers}
Use custom headers for intentional purposes. Avoid using custom headers to change HTTP protocol behavior.

\subsection{Resource identification from domain nouns}
Analyze your domain dictionary for resourcess which user can operate e.g.: CRUD operations and use POST, DELETE, PUT and GET methods for it.

\subsection{Resource granulity}
Use network efficiency, size of representations and client convenience to guide resource granularity.

\subsection{Resource organisation into collections}
Group only this resources which shares some kind of commonality.

\subsection{Resource combining and composition}
Basing on latency and performance criteria identify new resources which aggregate other resources to reduce number of client/server round-trips.

\subsection{Computing and processing functions}
Treat processing functions as resources and use GET method for obtaining results from its. Query parameters should handle inputs processing function.

\subsection{Controlles which are operating on resources}
Use POST method for all controllers operational method with 201 (Created), 303 (See Other) response code and \textit{Location} header with address a newly created/modified resource.

\subsection{Annotating representations with entity headers}
Headers which should be added on server request or response to the client for all representations:
\begin{itemize}
	\item \textit{Content-Type} - MIME type
	\item \textit{Content-Length}
	\item \textit{Content-Language}
	\item \textit{Content-MD5}
	\item \textit{Content-Encoding} - gzip, compress, deflate
	\item \textit{Last-Modified}
\end{itemize}

\subsection{Interpretation of Entity Headers}
Headers listed below should obligatory for all responses:
\begin{itemize}
	\item \textit{Content-Type} - Do not guess type and respond with 400 (Bad Request) to the server for all request without this header.
	\item \textit{Content-Length}
	\item \textit{Content-Encoding}
	\item \textit{Content-Language}
\end{itemize}

\subsection{Avoiding character encoding mismatch}
Add \textit{charset} attribute for all content-types which supports this e.g.: \textit{Content-Type: application/xml;charset=UTF-8}.

\subsection{Choosing representation format and media type}
Allow varying application use cases and client needs for each resource and do not assign fixed formats and media types for resource. At first use IANA media from registry, then use extensible format (ATOM, XML, JSON). For \textit{Content-Disposition} use most uncommon and closest formats otherwise prefer well-known media types and formats.

\subsection{Designing XML representations}
Include a self link (e.g. ATOM link with relation type self) to the resource and include identifiers for each application domain entities that makes up a resource. Add xml:lang attributes indicating the language that the contents of that element are localized in.

\subsection{Designing JSON representations}
Include a self link (e.g. object with relation property and value "self") to the resource and include identifiers for each application domain entities that makes up a resource. Add lang attributes indicating the language that the contents of that element are localized in (objects with text have two attributes lang and text-value in specified language).

\subsection{Designing representation of Collections}
Each collection representation should have:
\begin{itemize}
	\item Self link to the collection resource.
	\item When collection is paginated and has next page include link for next page.
	\item When collection is paginated and has previous page include link for previous page.
	\item Indicator with size of collection.
\end{itemize}

\subsection{Homogeneous Collections}
Design the representation of collection such that members in a collection are structurally and syntactically similar.

\subsection{Portable data formats for representations}
Use portable formats except text which will be presented to end users like this:
\begin{itemize}
	\item ISO 3166 for countries and territories.
	\item ISO 4217 for currency.
	\item RFC 3339 for date/time.
	\item Use time zones from Olson Time Zone Database.
	\item BCP 427 for language tags.
	\item Decimal, float and double defined in W3C XML Schema for floatting numbers - even currency.
\end{itemize}

\subsection{Using entity identifiers}
For each application domain entity include representation of a resource, include identifiers formatted as URNs.

\subsection{Encoding binary data in representations}
Use media types from list below:
\begin{itemize}
	\item multipart/mixed - binary data mixed with textual context.
	\item multipart/related - binaries related to other resource by root part and Content-ID header.
	\item multipart/alternative - alternative representations for the same resource.
	\item multipart/form-data - files uploaded by HTML forms use this media type.
\end{itemize}

Avoid using Base64 encoding for binary data.

\subsection{How to serve HTML representations}
For end-users use HTML formatted representations, for crawlers and such software use RDF or microformats to annotate important data. Do not provide HTML representations for machine clients.

\subsection{How to return errors}
For errors from clients inputs use 4xx statuc code family. For errors from server side use 5xx status codes. Use in both cases Date header (eror date-time). Unless the method is HEAD include body with formatted representational data and localized with content-negotiation. You can use \textit{Link} header for providing address with information about this kind of error.

\subsection{How to treat errors in clients}
\begin{itemize}
	\item 400 (Bad Request) - look into body and search clues and solutions for your problem.
	\item 401 (Unauthorized) - prompt user about credentials.
	\item 403 (Forbidden) - client accessed missing or protected resorurce.
	\item 404 (Not Found).
	\item 405 (Not Allowed).
	\item 406 (Not Acceptable).
	\item 409 (Conflict).
	\item 410 (Gone).
	\item 412 (Precondition Failed).
	\item 413 (Request entity too large).
	\item 415 (Unsupported Media Type).
	\item 500 (Internal Server Eror).
	\item 503 (Service Unavailable).
\end{itemize}

\subsection{Designing URIs}
\begin{itemize}
	\item Use domains and subdomains to logically group or partition resources for localization, distribution, or to enforce various monitoring or security policies.
	\item Use forward-slash separator to indicate a hierarchical relationship between resources.
	\item Use commas and semicolons to indicate nonhierarchical elements in the path portion of the URI.
	\item Use hyphen and underscore characters to improve readability of names in long path of segments.
	\item Use the ampersand to separate parameters in the query portion of the URI.
	\item Avoid including file extensions (such as \textit{php}, \textit{aspx}, \textit{jsp} etc.) in URIs.
	\item Spaces should be encoded as \%20, however with \textit{application/x-www-form-urlencoded} media type whitespaces are encoded by a plus sign (+) - beware of this type, because isn't only a browsers problem but with common libraries also.
	\item Case insensitive rule is working only for scheme and host parts, not on URIs - so HTTP://EXAMPLE.ORG/My-Folder/URI and http://example.org/My-Folder/URI are the same but http://example.org/My-Folder/URI and http://example.org/my-folder/uri aren't. However windows based server interpret this kind of URIs as the same. Avoid uppercase and case sensitivity differentiation in your resources URIs.
\end{itemize}

\subsection{URIs as an opaque identifiers}
Use only the URI to determine which resource processes a request. Do not tunnel repeated state changes over POST using the same URI or using custom headers to overload URIs. Headers should use only for informational purpose.

\subsection{How to let clients treat URI as an opaque identifier}
Whenever possible, priovide URIs at runtime using links in the body of representations or headers.

\subsection{Keeping URIs Cool}
Design URIs based on stable concepts, identifiers and information. Use rewrite rules on the server to shield clients from implementation-level changes. Honor old URIs in case when URIs must change and issue redirects to clienbts with new  URI using 301 (Moved Permanently) or, in rare cases, by issuing 410 (Gone) for URIs are no longer valid.

\subsection{How to use links in XML representations}
Use the link element defined in Atom, which has following attributes:
\begin{itemize}
	\item href
	\item rel - type of the link, indicate relations.
	\item title (optional) - human readable title for link.
	\item type (optional) - hint to the media type of the representation that the server may return.
	\item hreflang (optional) - hint to the content language of the representation that the server may return.
	\item length (optional) - that is a hint to the content length of the representation that server may return.
\end{itemize}

\subsection{How to use links in JSON representations}
For each link, use a link property (or a links to include more than one link as an array) whose value is a link object or a link array. For each object include href and rel attributes.

\subsection{When and how to use link headers }
A link header provides a way to convey a link as an HTTP header. Format: \textit{Link: <URI>;rel="{relation}";type="{media type}";title="{title}"}. Use this format when you want to convey links in format-independent manner or when representation format doesn't support links.

\subsection{How to assign link relation types}
Relation types (\textit{rel} attribute values set):
\begin{itemize}
	\item self - link to the preferred URI of the resource.
	\item alternate - providing a link to a URI for an alternative version of the same resource.
	\item edit - use this type when provided link can be used to editing a resource.
	\item related - indicates a related resource.
	\item previous, next - use this type of link to the previous/next resource in a ordered series of resources.
	\item first, last use this type to indicate first/last resource in an ordered series of resources.
\end{itemize}

\subsection{How to use links to manage application flow}
Design each representation such that it contains links that help clients transition to all the next possible steps. If the server needs to carry start from one step to the next, encode the state in links for e.g.:
\begin{itemize}
	\item POST - http://www.example.org/hires - Create a candidate resource.
	\item POST - http://www.example.org/hires/{id}/refs - Submit reference comments.
	\item POST - http://www.example.org/hires/{id}/bgchecks - Submit background check results.
	\item POST - http://www.example.org/hires/{id}/hire - Make an offer.
	\item POST - http://www.example.org/hires/{id}/no-hire - Don't make an offer.
\end{itemize}

\subsection{How to deal with ephemeral URIs}
Communicate ephemeral URIs via links. Assign extended relation types for those links and document how long such URIs are valid and what the client should do after the expiry. When a client submit a request for an expired URI return an appropriate 4xx error code with instructions in the body on any actions the client can take.

\subsection{When and how to use URI templates}
A URI template is a string consisting of tokens marked off between matching braces ({ and }). Clients substitute these tokens (including brace) with URI-safe strings to convert template into valid URI. Limit the tokens to the following parts of URIs:
\begin{itemize}
	\item Path segments as in http://www.example.org/segment1/{token1}/segment2
	\item Values of query parameters as in http://www.example.org/path?param1={value1}
	\item Values of matrix parametrs as in http://www.example.org/path;param1={value1};param2={value2}
\end{itemize}

To include a URI template in a representation use the following:
\begin{itemize}
	\item Use a link-template element defined in your own application XML namespace. Keep compatibility with link element.
	\item For JSON representations use link-template or link-templates properties to convey URI templates.
\end{itemize}

\subsection{How to use links in clients}
To support URIs and URI templates provided by the server, extract URI and URI template from links based on known link relation types. These links along with other resource data constitute the current state of application.

\subsection{How to model resources using Atom}
Model resources as entries and collections as feeds. The representation of an entry is an XML document with the entry element defined in Atom as the root element. The representation of a feed is an XML document with the feed element as the root element. A feed document consists of several entry elements. These elements are defined in Atom namespace. The most commonly used prefix is atom.

\subsection{When to use Atom}
Use Atom when the information model or metadata of resources naturally maps to the syntax and semantics of Atom feeds and entries. Even when the information model of resources does not map to Atom, consider offering Atom feeds with entries consisting of short text, HTML or XHTML summaries of resources links to them. Users can learn about those resources by relying on feed-capable tools such as feed readers.

\subsection{How to use AtomPub Service and Category documents}
Use the service document resource to group collections into workspaces. The representation of this resource is an XML document with service as the root element defined in http://www.w3c.org/2007/app namespace. The most commonly used namespace prefix is app. The media type of this representation is \textit{application/atomsvc+xml}. 

A service consists of one or more workspaces (app:workspace). Each workspace consists of several collections (app:collection) listing URIs of all feeds, media types that they accept (app:accept), and categories (app:category).

A category resource lists categories of resources in a collection. Its representation is an XML document with category as the root element. It consists of atom:category elements. The media type of this representation is \textit{application/atomcat+xml}.

\subsection{How to use AtomPub for feed and entry resources}
Allow clients to create new resources by submitting an Atom entry document as the body of a POST request using the URI of the Atom feed as a factory. Clients can subsequently use the link with the edit relation type to modify (using PUT) or delete (using DELETE) the resource.

\subsection{How to use media resources}
Atom uses a media link entry with each media resource. Since media resources may be binary resources, you can use a media link entry to provide metadat for each media resource.

If a collection (e.g. feed) supports media resources, list the supported media types in the service document.

Let clients create media resources by submitting POST request to the collection. Create the media resource and a media link resource. Return the URI of the media link resource via Location header. In the representation of the media link resource, provide the URI of the newly created media resource via the src attribute of the atom:content element. If server supports editing media resources, include a link with relation edit-media in the Atom entry. Clients can use this link to retrive, update or delete the media resource.

\subsection{How to indicate client preferences}
When making a request, add an Accept header with a comma-separated list of media type preferences. If the client prefers one media over the other, add a \textit{q} parameter with each media type. This parameter indicates a relative preference for each media type listed in \textit{Accept-*} headers. It is most commonly used with the \textit{Accept} header. If the client can process only certain formats, add \textit{*; q=0.0} in the \textit{Accept} header to indicate to the server it cannot process anything other than the media types listed in the \textit{Accept} header. In analogy - when client accepts only one type of charset, language or encoding it must add \textit{Accept-*} header with Charset, Language or Encoding parameters. If not it should skip these headers.

\subsection{How to implement media type negotiation}
If the request has no Accept header, return a representation using the default format for the requested resource. If the request contains Accept header, parse the header and sort the values of media types by the \textit{q} parameters in descending order. Then select a media type from list that server supports. Include \textit{Vary} response header if media type differs than first from sorted list media type sent from client. Use failure response when server doesn't support any of media types from the list.

\subsection{How to implement language negotiation}
If the request hasn't Accept-Language header return a response with all human readable text in a default language. If the request has an Accept-Language header, parse the header, sort languages by the \textit{q} parameters, and select the first language in the list that the server can support. Include a \textit{Vary} response header as above. If server doesn't support any languages in the list and the \textit{Accept-Language} header doesn't contain \textit{*; q=0.0} use a default language for that resource.

\subsection{How to implement character encoding negotiation}
If the request hasn't Accept-Charset header return a response with UTF-8 encoding. If the request has an Accept-Charset header, parse the header, sort charsets by the \textit{q} parameters, and select the first charset in the list that the server can support. Include a \textit{Vary} response header as above. If server doesn't support any charset in the list and the \textit{Accept-Charset} header doesn't contain \textit{*; q=0.0} use a UTF-8 encoding.

\subsection{How to support compression}
If the server is capable of compressing-response body, select the compression technique from \textit{Accept-Encoding} header. Include a \textit{Vary} response header as above. If no encoding in this header matches to the server's supported encodings, ignore this header. The \textit{q} parameters are handled as above.

\subsection{When and How to send the vary header}
Include a \textit{Vary} header whenever multiple representations are available for a resource. The value of this header is a comma-separated list of request headers the server uses when choosing a representation. If the server uses information other than the headers in the request, such as the client's IP addresss, time of the day, user personalization, etc. include a \textit{Vary} header with a value of \textit{*}.

\subsection{How to handle negotiation failures}
When server cannot serve a representation that meets the client's preferences and if the client explicitly included a \textit{*/*;q=0.0} return status code 406 (Not Acceptable) with the body of representation containing the list of representations. Remember about serving without applied Accept-Encoding representation when server is unable to serve specified content encoding.

\subsection{How to use agent-driven content negotiation}
Provide a URI for each representation.

\subsection{When to support server-driven negotiation}
Support multiple variants when only your clients need them or whether each variant contains the same information. If the information content is different, use a distinct URI for each.

\subsection{How to design URIs for queries}
Use query parameters to let clients specify filter conditions, sort field, and projections. Treat the query parameters as optional with sensible defaults. To support commonly used queries, use predefined named queries.

\subsection{How to design query response}
Design the response of a query as a representation of a collection resource.

\subsection{How to support query requests with large inputs}
Use HTTP POST to support large queries.

\subsection{How to store queries}
When a client makes a query request using POST, create a new resource whose state contains the query criteria. Return response code 201 (Created) with a Location header referring to a resource created. Implement a GET request to this new resource such that it returns query results.

\subsection{How to set expiration caching headers}
Based on frequency of updates, determine a time period during which caches can server a representation. This time period is the freshness lifetime. After this time, caches will consider cached representation stale.

When serving a representation, include Cache-Control header with a max-age value (in seconds) equal to freshness lifetime. The Cache-Control header is an HTTP 1.1 header. To support legacy HTTP 1.0 caches, also include Expires header with expiration date-time. The expiration time is a time at which server generated the representation plus the freshness lifetime. Also include a Date header with a date-time of the time at which the server returned response. Including this header helps clients compute the freshness lifetime as the difference between the values of the Expres and Date headers.

If you determine that caches must not server cached copies, add a Cache-Control header with value no-cache. In this case, also add \textit{Pragma: no-cache} header to support legacy HTTP 1.0 protocol.

\textit{Cache-Control} values and their applicability:
\begin{itemize}
	\item public - Default, use this when request is authenticated but you still want to allow shared caches to server cached responses.
	\item private - Use this directive when response is private to the client or the user. When this directive is present, any client-side cache (e.g. browser cache) can cache representation, but shared caches such as those at the server or along the network must not cache it. Add this directive when serving representations based on client or user authentication.
	\item no-cache, no-store - Add these directives to prevent any cache from storing or serving a cached response.
	\item max-age - Use the freshness lifetime in seconds as the value of this directive.
	\item s-maxage - This directive is similar as above, but it meant only for shared caches.
	\item must-revalidate - Use this directive to require caches to check the origin server before serving stale representations.
	\item proxy-revalidate - This directive is similar as above except that it applies only to shared caches.
\end{itemize}

\subsection{When to set expiration caching headers}
Set expiration caching headers for responses of GET and HEAD requests for all successfull response codes. Although POST is cacheable, caches consider this method as noncacheable. You need not set expiration headers on other methods. In addition to successful responses with 200 (OK) response code, consider adding caching headers to the 3xx and 4xx response codes. This will help reduce the amount of error-triggering traffic from clients. This is called \textit{negative caching}. Samples: 300 (Multiple Choices), 301 (Moved Permanently), 400 (Bad Request), 403 (Forbidden), 404 (Not Found), 405 (Method Not Allowed), 410 (Gone).

\subsection{When and how to use expiration headers in clients}
Unless you're building a shrink-wrapped client application that users install and run, avoid implementing support for expiration caching within client application. Instead deploy a forward proxy cache in the client network, and avoid implementing your own caching layer in client code.

\subsection{How to support caching for composite resources}
Base caching decisions on the part of the data has the strongest freshness requirements. Set expiry headers based on how frequently such data changes.

\subsection{How to keep caches fresh and warm}
Whenever possible, synchronize expiry with the frequency of updates. When this is not possible, implement background processes to watch for database updates, and schedule unconditional GET requests to refresh caches. Make sure to account for database replication delays while sheduling such requests. If you want purge cached representations, check documentation of your cache. Note that you can purge representations only from the caches that are in your control. There may be several downstream caches that may continue to hold cached copies.

\subsection{How to generate Last-Modified and ETag headers}
If you've control on the data store used for storing resources, modify the storage schema for each resource to include a timestamp for the modified date-time and/or a sequence number to keep track of a version.

In this case of relational databases, use database triggers to automatically update these fields whenever data is modified/

If you can't modify the storage schema or if your data store does not permit maintaining timestamps or sequence numbers, use some function of the resource data to generate a value for the ETag header. Store this value and a timestamp in a separate table or data store such that the server does not need to reload the entire representation to compute this.

If the representation size is not large, use representation body to generate an md5 hash value for the ETag. Alternatively, use some field of the data that changes every time the resource is updated. Make sure to use different ETag value for each representation of the resource.

\subsection{How to implement conditional GET requests in servers}
Design to keep track of last modification date-time and/or entity tags. Include the last-modified date-time as the last Last-Modified header and the entity tag as the ETag header when serving representation.

When responding to GET and HEAD requests from the client, if the client has sent an If-None-Match header, compare its value with the ETag of the representation on the server. If the client has sent an If-Unmodified-Since, compare its value with the last-modified time of the representation on the server.

If either checks are false or if the client sent neither of these headers, return the latest copy of the representation to the client including new ETag and/or Last-Modified headers. If not, return HTTP status code 304 (Not Modified) to the client with no message body.

\subsection{How to submit conditional GET and HEAD requests from clients}
When a server returns Last-Modified and/or ETag headers, store them along with the representation data. When making GET and HEAD requests for the same resource in the future, include the following headers to make these requests conditional:
\begin{itemize}
	\item If-Modified-Since header with a value of the stored Last-Modified header.
	\item If-None-Match header with a value of the stored ETag header.
\end{itemize}

\subsection{How to implement conditional PUT requests in servers}
If the resource does not exist yet and if the server supports resource creation via PUT, create a new resource at the URI specified by the client. If the server does not support resource creation, return 404 (Not Found) status to the client.

If the resource exists, take following steps:
\begin{itemize}
	\item If the client doesn't include If-Unmodified-Since and/or If-Match headers, return 403 (Forbidden). Explain why in the body of the response.
	\item If the supplied If-Unmodified-Since or If-Match headers do not match the actual modified date-time and ETag values of the representation on the server, return error code 412 (Precondition Failed).
	\item If the clients submits a conditional PUT request and if the supplied conditions match, update resource, and return 200 (OK) or 204 (No Content). You can optionally include updated Last-Modified and/or ETag headers provided the response also includes a Content-Location header with the URI of the updated resource.
\end{itemize}

\subsection{How to implement conditional DELETE requests in servers}
If the client submits an uncoditional DELETE request, return error code 403 (Forbidden). If the supplied conditions not match, return code 412 (Precondition Failed). In either case, explain the reason for the failure to the client in the body of the representation.

If the clients submits a conditional DELETE request and the supplied conditions match, delete the resource.

\subsection{How to make unconditional GET requests from clients}
Include Cache-Control: no-cache and Pragma: no-cache in the GET request.

\subsection{How to submit conditional PUT and DELETE requests from clients}
When the client is creating a new resource by using PUT or the server hasn't returned If-Modified-Since and/or ETag headers from a previous GET or PUT request to the resource, make PUT requests as usual.

If the client has If-Modified-Since and/or ETag headers from a previous request to the resource, when making PUT and DELETE requests, include the following headers to make these requests conditional:
\begin{itemize}
	\item An If-Unmodified-Since header with the same value as the Last-Modified header, to indicate that the server should process the request if and only if the server has not modified the resource since the time specified in this header.
	\item An If-Match header, with the same value as the ETag header, to indicate that the server should process the request if and only if the supplied header value matches the current ETag value.
\end{itemize}

If the server return status code 412 (Precondition Failed), submit an unconditional GET request to obtain fresh Last-Modified and ETag headers, verify that the decision to update or delete the resource is still valid per the fresh representation and then repeat PUT and DELETE request with those headers.

\subsection{How to make POST requests conditional}
Let clients use a one time URI supplied by the server via link for each POST request. This URI contains a token generated by the server that is valid for just one usage of the POST request. Store all used tokens in a transaction log on the server. When the client submits a POST request, verify whether the token exists in the transaction log. If it does, return response code 403 (Forbidden). Explain why in the body. If not, process the request to return 201 (Created) or 303 (See Other) depending on the outcome. Also store the token in the transaction log.

\subsection{How to generate one-time URIs}
If the purpose of the URI is to create a new resource, generate token based either on a sequence number or on a concatenation of a timestamp and a random number. If the purpose of URI is to modify one or more resources, also include the entity tags and identifiers of those resources in the token. Encode that token in the URI.

\subsection{How to copy a resource}
Design a controller resource that can create a copy. The client makes a POST request to this controller to copy resource. To make POST conditional, provide one-time URI to the client. After the controller creates the copy, return response code 201 (Created) with a Location header containing the URI of the copy.

\subsection{How to merge resource}
Desing a application-specific controller resource to merge resources. The client submits a GET request to this URI with URIs or identifiers of the resources to be merged to this controller as query parameters. The server returns a Last-Modified, and an ETag header along with a summary of the resources to be merged in the body of the representation. In the entity tag, include a sequence number or a concatenation of a timestamp and a random number. 

Upon veryfing a summary, the client makes a POST request supplying If-Unmodified-Since and If-Match headers to the same URI to cause the merge.

After merging, the server stores the If-Match header value in a transaction log and returns response code 201 (Created) with a Location header containing the URI of the merged resource. In the future, if a client submits a POST request with the same If-Match value, the server returns 412 (Precondition Failed).

\subsection{How to move a resource}
Include a link or a link template to a controller that can move the resource. Let the client use POST to submit a request to move (conditional). After processing requst, return response code 201 (Created) or 303 (See Other) depending on the outcome.

\subsection{When to use WebDAV methods}
Use WebDAV-specifed methods when your wbe service are file-centric operations and it is a content-authoring application and if your servers can support WebDAV. Avoid using WebDAV for other kinds of applications.

\subsection{How to support operations accross servers}
Let servers collaborate with each other to design and implement cross-server operations. This may involve servers agreeing on data formats, backend interfaces and concurrency control, as well as loading data from one data store, normalizing it to meet the other server's format and then storing it. Let on servers provide a link to clients to trigger the operation.

\subsection{How to take snapshot of resources}
Every time a client submits PUT request to update a resource, before updating the resource implicitly create snapshot (a copy resource). In the representation of the updated resource, include a link to the snapshot. Also include a link in the snapshot resource to the updated element. When a client submits a DELETE request, delete resource along with all the snapshots.

\subsection{How to undo resource updates}
Every time a client submits a PUT update a resource take a snapshot. Provide a controller resource for undo. To undo a change, let client submit a POST request. Log the current state of the resource in a transaction log for auditing purposes. The server restores the state of the resource from the latest snapshot and redirects the client to the URI of the resource.

\subsection{How to refine resources for partial updates}
Design a new resource that encapsulates the parts of the resource that a client can modify. Let clients use PUT to update that resource, in effect partially updating the original resource.

\subsection{How to use PATCH method}
The PATCH method is an unsafe and nonidempotent HTTP method. The body of the request is a representation which describes a set of changes that need to be made to the resource. On the receiving this request, the server applies the changes to the resource and returns 200 (OK) or 204 (No Content). Make the implementation of this method conditional by requiring clients to supply If-Unmodified-Since and/or If-Match headers. Return response code 412 (Precondition failed) if supplied parameters do not match.

Advertise support for the PATCH via the Allow header of the OPTIONS response. Also include an Accept-Patch header with the supported media types for the PATCH method.

\subsection{How to process similar resources in bulk}
Use POST and a collection resource to create a number of similar resources at once. Let clients include information about the resources to be created in the request. Assign a URI for all the resources created, and redirect the client to the collection using response code 303 (See Other). A representation of this resource includes liks to all the newly created resources.

To update or delete a number of similar resources in bulk, use single URI that can return a representation containing information about all those resources. Submit a PUT request to that URI with information about the resources to be updated or a DELETE request to delete those resources. In all these cases, ensure that the processing of the request is atomic. Beware of size of request and long running operations because of denial-of-service attack or unintentional server blocking.

\subsection{How to trigger bulk operations}
Design a controller resource that, with some clients inputs, can start executing a bulk operation. Allow the client to use POST request to initiate processing. If the processing needs to be tracked by the client or if the client needs to submit large amount of data for the operation return response code 202 (Accepted). If not return 200 (OK) or 204 (No Content).

\subsection{When to tunnel multiple resources using POST}
Avoid tunneling of multiple HTTP requests within a single POST request. Instead design application-specific resources to process batch requests without tunneling.

\subsection{How to support batch requests}
When confronted with a need to tunnel several HTTP requests via a POST request, backtrack to analyze the use case that prompted such an approach. Design an application-specific controller resource that can support the same use case without generalizing the problem into one of tunneling multiple requests via POST.

\subsection{How to support transactions}
Provide a resource that can make atomic changes to data. Treat uncommitted state as application state, and manage is as part of URI. If the server needs to allow clients to undo actions use PUT, DELETE, or POST as appropriate to make compensating changes.

\subsection{How to use basic authentication to authenticate clients}
On the server, when client submits a request to access a protected resource, return response code 401 (Authorization Required) along with WWW-Authenticate header e.g.: \textit{WWW-Authenticate: Basic realm="Some name"}.

On the client, concatenate the client identifier (e.g. username if the client is making a request on behalf of a user) and shared secret (such as password) as <identifier>:<secret>, and then compute base64 encoding of this text. Include value of the resulting text in an Authorization header in client requests e.g.: \textit{Authorization: Basic <base64 encoded value>}.

On the server decode text, and verify that the secret is the same.

If the client knows a priori that the server requries basic authentication for a resource it can include Authorization header with each request and avoid receiving 401 response with the WWW-Authenticate header. To facilitate this, include authentication requirements in the server's documentation. Authorization header is extensible e.g. S3 (Amazon's Simple Storage Service) uses this header to let clients authenticate with AWSAccessKeyId - non standard solutions are possible.

\subsection{How to use digest authentication to authenticate clients}
When a client submits a request without including an Authorization header to access a protected resource, return response code 401 along with a WWW-Authenticate header, Digest authentication scheme, and at least realm and nonce directives. A nonce is a number or a token that can be used once or only a limited number of times.

On the client, include an Authorization header that contains a digest of the client or user identifier, the realm and the shared secret.

Upon veryfing that the supplied digest matches a digest of credentials stored in the server, include an Authentication-Info response header. This is a server-side equivalent of the Authorization header.

By default, client user MD5 to compute the digest. Unlike basic authentication, this technique does not exchange an unencrypted shared secret.

\subsection{How to use three-legged OAuth}
At the start of the protocol, the server uses a \textit{consumer key} as an identifier for the client and a \textit{consumer secret} as a shared secret. Once a user authorizes the client to access her resources, the server uses an \textit{access token} as an identifier and a \textit{token secret} as a shared secret to access the user's protected resources.
\begin{itemize}
	\item \textit{Consumer Key} and \textit{Consumer Secret} - key is an unique identifier for the client. The client uses the consumer secret to sign the request to obtain request tokens.
	\item \textit{Request Token} and \textit{Token Secret} - request token is a temporary one-time identifier issued by the server for the purpose of asking the user to grant permission to the client. The token secret is used to sign the request to obtain an access token.
	\item \textit{Access Token} and \textit{Token Secret} - The acces token is an identifier for use by the client to access user's resources. A client in possesion of an access token can access user's resources as long as the token is valid. The server revoke it any time either due to expiry or due to the user revoking the permission. The secret is used to sign requests to access the protected user's resources.
\end{itemize}

Steps to use three-legged OAuth:
\begin{itemize}
	\item 1. The client requests the server for a customer key and a customer secret out of band.
	\item 2. The client uses the consumer key to obtain a request token and a secret.
	\item 3. The client directs the user to the server to grant permissions to let the client access the user's resources. This process results in an authenticated request token.
	\item 4. The client requests the server to provide an access token and secret. These represent an identifier and shared secret that the client use to access resources on behalf of the user.
	\item 5. When making a request to access a protected resource, the client includes an Authorization header (or query parameters) containing the consumer key, the access token, the signature method and signature, the timestamp, a nonce optionally the version of the OAuth.
\end{itemize}

OAuth recommends using POST to obtain request and access tokens.

\subsection{How to use two-legged OAuth}
Steps to use two-legged OAuth:
\begin{itemize}
	\item 1. The client requests the server for a customer key and a customer secret out of band. Key is an identifier for the client. The consumer secret is a secret shared between the client and the server.
	\item 2. When making a request to access a protected resource, the client includes an Authorization header (or query parameters) containing the consumer key, the access token, the signature method and signature, the timestamp, a nonce optionally the version of the OAuth.
\end{itemize}

Name is from two elements which are involved in authentication process. Use this type of OAuth when the server needs to authenticate the client to provide access control, logging, metering, rate limiting and metrics.

\subsection{How to deal with sensitive information in URIs}
To detect tampering, compute a digital signature of data in URIs using algorithms such as HMAC-SHA1 and RSA-SHA1. Include the signature as a query parameter in the resource URI. If the data in URIs is confidential, encrypt the data algorithms such as AES, Blowfish, DES, Triple DES, Serpent, Twofish, etc. Make sure to Base64-encode the result before including it in the URI.

\subsection{How to maintan the confidentiality and integrity of representations}
Use TLS and make resources accessible over a server configured to server requests only using HTTPS.

\subsection{How to maintain URI compatiblity}
Keep URI permanent. Treat request URIs containing the same query parameters but in a different order as the same. Clients must be able to get the same behavior irrespective of the order of the query parameters.

When you add new parameters URIs continue to honor existing parameters, and treat new parameters as optional. When changing data formats for query parameters, continue to honor existing formats. If that is not viable, introduce format changes via new query parameters or new URIs. By default, treat query parameters in URIs as optional except when such parameters are needed for concurrency or security reasons.

\subsection{How to maintain compatibility of XML and JSON representations}
Design an XML format to keep the child elements unordered. When making changes to XML and JSON, preserve the hierarchical structure so that clients can continue to follow the same structure to extract data.

Make new data elements in requests optional to maintain compatibility with existing clients. Clients that do not send new data fields must be able to continue to function.

Do not remove or rename any data fields from representations in response bodies.

\subsection{How to extend Atom}
Define new link relations. Add new child elements or attributes to atom:feed and atom:entry elements as long as such extensions do not hamper the proper function of clients and other software that does not know about such extensions.

When adding foreign content under the atom:content element, provide human-readable text or XHTML under the atom:summary element.

\subsection{How to maintain compatibility of links}
Avoid removing links, do not change the values of rel and href attributes of links. When introducing new resources, use links to provide URIs of those resources to clients.

\subsection{How to implement clients to support extensibility}
When parsing bodies of representationsm, look for known data. In the case of XML, look for known elements and attributes by name and not by position. Implement the client to not fail when it finds unrecognized data. If the client is capable of storing the complete representation locally, store everything.

Do not assume that the representation received from the server is of fixed media type, character encoding, content language or content encoding. As described earlier read these values from corresponding Content-* headers and process them accordingly.

\subsection{When to version}
Consider versioning when the server is unable to maintain compatibility. Also consider versioning if some clients require behavior or functionality different from other clients.

\subsection{How to version RESTFul Web Services}
Add new resources with new URIs when there is a change in the behavior of resources or a change in the information contained in representations. Use easily detectable patterns usch as v1 and v2 in subdomain names, path segments or query parameters to distinguish URIs by their version.

Avoid treating each version as new representation with a new media type of the same resource.

\subsection{How to document RESTFul Web Services}
Fully describe the following in human-readable documentation:
\begin{itemize}
	\item All resources and methods supported for each resource.
	\item Media types and representation formats for resources in requests and responses.
	\item Each link relation used, its business significance, HTTP method to be used, and resource that the link identifies
	\item All fixed URIs that are not supplied by links.
	\item Query parameters used for all fixed URIs.
	\item URI templates and token substition rules.
	\item Authentication and security credentials for accessing resources.
\end{itemize}

For XML representation, if your clients and servers are capable of supporting XML schemas, use a schema language as a convention to describe structure of XML documents used for representations in requests and responses. For other formats use conventions to describe representations in prose.

\subsection{How to use OPTIONS}
On the server side, implement OPTIONS to return list of supported methods via the Allow response header.

When a resource supportes PATCH method, add Accept-Patch header with listed media types supported for PATCH requests.

Optionally add a Link header containing human-readable document that describes the resource.

\end{document}